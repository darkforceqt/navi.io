<!DOCTYPE html><html lang="en"><head>
    <meta charset="UTF-8">
    <meta property="og:title" content="Navi.io" />
    <meta property="og:description" content="Browser-friendly 2D tank game. Earn the highest score possible by killing shapes and enemies." />
    <meta property="og:image" content="https://image2url.com/r2/default/images/1770402096647-d11c3823-59ca-4f59-9c35-7b32d9b18934.png"/>
    <link rel="icon" type="image/x-icon" href="https://image2url.com/r2/default/images/1770402096647-d11c3823-59ca-4f59-9c35-7b32d9b18934.png">
    <title data-id="th-modified">Navi.io</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;500;700&display=swap');
        body { margin: 0; overflow: hidden; background: #b0b0b0; font-family: 'Ubuntu', sans-serif; user-select: none; touch-action: none; }
        canvas { display: block; background-color: #cdcdcd; }
        #ui-layer { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            pointer-events: none;
        }
            
.joystick-container {
    position: absolute;
    width: 240px;
    height: 240px;
    background: rgba(205, 205, 205, 0.5);
    border-radius: 50%;
    pointer-events: none;
    z-index: 10;
}
.joystick-knob {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 50px;
    height: 50px;
    background: rgba(125, 125, 125, 0.5);
    border-radius: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none;
}
        #menu-screen { position: absolute; inset: 0; background: rgba(0,0,0,0.5); display: flex; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; }
        #death-screen { display: none; position: absolute; inset: 0; background: rgba(40, 0, 0, 0.85); backdrop-filter: blur(5px); flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; color: white; text-align: center; }
        .btn-group { display: flex; gap: 10px; margin-bottom: 15px; }
        .mode-btn { padding: 8px 15px; cursor: pointer; background: #555; color: white; border: 2px solid #333; border-radius: 4px; }
        .mode-btn.active { background: #00b2e1; border-color: #fff; }
        #evolution-menu { position: absolute; top: 20px; left: 20px; display: none; flex-direction: column; gap: 10px; pointer-events: auto; }
        .evo-btn { background: #00b2e1; color: white; border: 3px solid #0085a8; padding: 10px; border-radius: 5px; cursor: pointer; font-weight: bold; text-align: center; width: 120px; }
        #upgrades { position: absolute; bottom: 80px; left: 20px; pointer-events: auto; }
        .stat-row { display: flex; background: rgba(0,0,0,0.3); margin: 2px; padding: 2px 8px; border-radius: 4px; cursor: pointer; width: 220px; }
        .stat-bar { display: flex; flex-grow: 1; gap: 2px; align-items: center; margin-left: 5px; }
        .stat-seg { height: 10px; flex: 1; background: rgba(255,255,255,0.2); border-radius: 1px; }
        .hidden { display: none; }
        #hud-bottom { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); width: 400px; display: flex; flex-direction: column; align-items: center; }
        .progress-container { width: 100%; height: 16px; background: #555; border: 2px solid #333; border-radius: 8px; overflow: hidden; margin-top: 5px;}
        #xp-bar { height: 100%; width: 0%; background: #ffe869; transition: width 0.2s; }
        #leaderboard { position: absolute; top: 20px; right: 20px; color: white; text-align: right; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 5px; min-width: 170px; font-size: 14px; }
        #minimap { position: absolute; bottom: 20px; right: 20px; width: 150px; height: 150px; background: rgba(0,0,0,0.2); border: 2px solid rgba(255,255,255,0.3); }
        
        
#death-screen canvas {
    background: transparent;
    margin: 20px 0;
}
.hidden {
    display: none !important;
}
#death-stats {
    font-size: 18px;
    line-height: 1.6;
    margin-bottom: 20px;
}
.menu-card {
    background: rgba(15, 15, 15, 0.85);
    padding: 32px 36px;
    border-radius: 14px;
    width: 320px;
    display: flex;
    flex-direction: column;
    gap: 14px;
    box-shadow: 0 20px 60px rgba(0,0,0,0.5);
}

.game-title {
    color: rgb(235, 235, 235);
    font-size: 46px;
    margin: 0 0 10px;
    text-align: center;
}

.menu-input,
.menu-select {
    padding: 12px;
    font-size: 15px;
    border-radius: 6px;
    border: none;
    outline: none;
    background: #1f1f1f;
    color: white;
}

.menu-select {
    cursor: pointer;
    border: 1px solid #444;
}

.spawn-btn {
    display: none; 
    margin-top: 10px;
    padding: 14px;
    font-size: 16px;
    font-weight: bold;
    border-radius: 8px;
    border: none;
    cursor: pointer;
    background: linear-gradient(135deg, #00b2e1, #007ea6);
    color: white;
    transition: transform 0.15s, box-shadow 0.15s;
}
#copyPartyBtn{padding: 6px !important; hidden: true;}
.show-button {
    display: block !important;
    animation: fadeIn 0.5s;
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}
.spawn-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 6px 18px rgba(0,178,225,0.45);
}

.menu-footer {
    margin-top: 8px;
    font-size: 11px;
    color: #aaa;
    display: flex;
    justify-content: space-between;
}
.death-card {
    background: rgba(20, 0, 0, 0.85);
    padding: 30px 40px;
    border-radius: 16px;
    text-align: center;
    box-shadow: 0 25px 80px rgba(0,0,0,0.6);
}

.death-title {
    font-size: 42px;
    margin-bottom: 10px;
    color: #ff6b6b;
}

#death-stats {
    font-size: 16px;
    line-height: 1.7;
    margin: 18px 0;
}

.death-buttons {
    display: flex;
    gap: 14px;
    justify-content: center;
}

.death-btn {
    padding: 12px 28px;
    border-radius: 6px;
    border: none;
    cursor: pointer;
    background: #444;
    color: white;
    font-weight: bold;
}

.death-btn.primary {
    background: #00b2e1;
}
.custom-select {
    position: relative;
    width: 316px; /* Match your menu width */
    background: #1f1f1f;
    border: 1px solid #444;
    border-radius: 5px;
    cursor: pointer;
    font-family: sans-serif;
    color: white;
}

.select-trigger {
    padding: 10px;
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.flag-circle {
    width: 22px;
    height: 22px;
    border-radius: 50%;
    object-fit: cover;
    margin-right: 10px;
    border: 1px solid #555;
}

.custom-options {
    display: none;
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    background: #1f1f1f;
    border: 1px solid #444;
    z-index: 100;
}

.custom-select.open .custom-options {
    display: block;
}

.custom-option {
    padding: 10px;
    display: flex;
    align-items: left;
}

.custom-option:hover {
    background: #333;
}
        @media (max-width: 1024px) { #mobile-controls { display: block; } }
    </style>
    <style>
    /* Unified Custom Dropdown Styles */
    .custom-select {
        position: relative;
        width: 100%;
        background: #1f1f1f;
        /*border: 1px solid #444;*/
        border-radius: 6px;
        cursor: pointer;
        font-family: 'Ubuntu', sans-serif;
        color: white;
        margin-bottom: 10px;
        box-sizing: border-box;
    }

    .select-trigger {
        padding: 12px;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }

    .select-label {
        display: flex;
        align-items: center;
        gap: 12px;
        font-weight: 500;
    }

    .icon-circle {
        width: 24px;
        height: 24px;
        border-radius: 50%;
        object-fit: contain;
        background: rgba(255,255,255,0.05);
        opacity: 1;
    }

    .custom-options {
        display: none;
        position: absolute;
        top: calc(100% + 5px);
        left: 0;
        right: 0;
        background: #1f1f1f;
        border: 1px solid #444;
        border-radius: 6px;
        z-index: 100;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        overflow: hidden;
    }

    .custom-select.open .custom-options { display: block; }

    .custom-option {
        padding: 8px;
        display: flex;
        align-items: center;
        gap: 12px;
        transition: background 0.2s;
    }

    .custom-option:hover { background: #333; }

    /* Gamemode Specific Colors */
    .mode-ffa { color: #48bfe0; }     /* Blue */
    .mode-teams { color: #73c176; }   /* Green */
    .mode-4teams { color: #f47272; }  /* Red */
    .mode-maze { color: #fef7b8; }    /* Yellow */

    .arrow {
        border: solid #888;
        border-width: 0 2px 2px 0;
        display: inline-block;
        padding: 3px;
        transform: rotate(45deg);
        transition: transform 0.3s;
    }
    .custom-select.open .arrow { transform: rotate(-135deg); }
        #minimap-header {
    position: absolute;
    bottom: 175px; /* Positioned above the 150px minimap + 20px bottom margin */
    right: 20px;
    text-align: right;
    color: white;
    pointer-events: none;
    font-family: 'Ubuntu', sans-serif;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
}
#minimap-header .brand {
    font-size: 20px;
    font-weight: 700;
}
#minimap-header .count {
    font-size: 13px;
    font-weight: 400;
    opacity: 0.9;
}
.modal-overlay {
    position: absolute; 
    inset: 0; 
    background: rgba(0,0,0,0.8);
    display: flex; 
    align-items: center; 
    justify-content: center; 
    z-index: 1000;
    display: none;
    /* Added to ensure visibility toggle works */
}
.auth-card { width: 280px !important; }
.auth-buttons { display: flex; flex-direction: column; gap: 5px; }
.google-btn {
    display: flex; align-items: center; justify-content: center; gap: 10px;
    padding: 12px; border-radius: 6px; border: 1px solid #444;
    background: white; color: #333; font-weight: 500; cursor: pointer;
}
        #death-screen.saved-theme {
    background: rgba(255, 230, 0, 0.85); /* Bright Yellow */
}
#death-screen.saved-theme .death-card {
    background: rgba(40, 40, 0, 0.95);
    border: 3px solid #ffd700;
}
#death-screen.saved-theme .death-title {
    color: #ffd700;
}
#save-link-container {
    margin-top: 15px;
    display: none;
    flex-direction: column;
    gap: 5px;
}
.save-input {
    padding: 10px;
    background: #111;
    color: #ffd700;
    border: 1px solid #444;
    border-radius: 4px;
    width: 100%;
    box-sizing: border-box;
    font-size: 12px;
}
    #exit-btn {
        position: absolute;
        top: 20px;
        left: 20px;
        width: 45px;
        height: 45px;
        cursor: pointer;
        pointer-events: auto;
        z-index: 1001;
        transition: transform 0.1s;
        display: none; 
    }
        .custom-option {
    display: flex;
    align-items: center;
    justify-content: space-between;
}
.region-label-group {
    display: flex;
    align-items: center;
    gap: 10px;
}
.region-stats {
    display: flex;
    align-items: center;
    gap: 12px;
}
.stat-players {
    color: #48bfe0;
    font-weight: bold;
    font-size: 13px;
    display: flex;
    align-items: center;
    gap: 4px;
}
.stat-ping {
    color: #73c176; 
    font-weight: bold;
    font-size: 13px;
    display: flex;
    align-items: center;
    gap: 4px;
}
.stat-icon {
    width: 14px;
    height: 14px;
    object-fit: contain;
}
.select-trigger .stat-ping {
    display: none !important;
}
    #exit-btn:hover { transform: scale(1.1); }
    #exit-btn:active { transform: scale(0.9); }
.google-btn:hover { background: #f1f1f1; }
</style>
<script src="https://challenges.cloudflare.com/turnstile/v0/api.js" async="" defer=""></script>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="ui-layer">
        <img id="exit-btn" src="/navi.io/Assets/exit.png" onclick="exitGame()" alt="Exit">
        <div id="mobile-controls" style="display: none;">
        <div id="joystick-move" class="joystick-container" style="bottom: 50px; left: 150px;">
            <div class="joystick-knob"></div>
        </div>
        <div id="joystick-fire" class="joystick-container" style="bottom: 50px; right: 150px;">
            <div class="joystick-knob"></div>
        </div>
    </div>
    </div>

<div id="coin-display" class="hidden" style="position: absolute; top: 20px; left: 20px; color: #ffd700; font-weight: bold; font-size: 20px; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); pointer-events: none;">
    ðŸª™ <span id="user-coins">0</span>
</div>
   <div id="menu-screen">
    <div class="menu-card">
        <h1 class="game-title">Navi.io</h1>

        <div class="custom-select" id="modeDropdown">
            <div class="select-trigger">
                <div class="select-label mode-ffa">
                    <img src="/navi.io/Assets/ffa.png" class="icon-circle">
                    <span>Free For All</span>
                </div>
                <i class="arrow"></i>
            </div>
            <div class="custom-options">
                <div class="custom-option mode-ffa" data-value="FFA">
                    <img src="/navi.io/Assets/ffa.png" class="icon-circle"> Free For All
                </div>
                <div class="custom-option mode-teams" data-value="TEAMS">
                    <img src="/navi.io/Assets/2t.png" class="icon-circle"> 2 Teams
                </div>
                <div class="custom-option mode-4teams" data-value="4TEAMS">
                    <img src="/navi.io/Assets/4t.png" class="icon-circle"> 4 Teams
                </div>
                <div class="custom-option mode-maze" data-value="MAZE">
                    <img src="/navi.io/Assets/mz.png" class="icon-circle"> Maze
                </div>
            </div>
            <input type="hidden" id="modeSelect" value="FFA">
        </div>

    <div class="custom-select" id="customRegionSelect">
    <div class="select-trigger">
        <div class="select-label">
            <div class="region-label-group">
                <img src="/navi.io/flags/usa.png" class="icon-circle">
                <span>Atlanta</span>
            </div>
            <div class="region-stats">
                 </div>
        </div>
        <i class="arrow"></i>
    </div>
    
    <div class="custom-options">
        <div class="custom-option" data-value="frankfurt">
            <div class="region-label-group">
                <img src="/navi.io/flags/frankfurt.png" class="icon-circle"> <span>Frankfurt</span>
            </div>
            <div class="region-stats" id="stats-frankfurt"></div>
        </div>
        
        <div class="custom-option" data-value="atlanta">
            <div class="region-label-group">
                <img src="/navi.io/flags/usa.png" class="icon-circle"> <span>Atlanta</span>
            </div>
            <div class="region-stats" id="stats-atlanta"></div>
        </div>
        
        <div class="custom-option" data-value="LA">
            <div class="region-label-group">
                <img src="/navi.io/flags/usa.png" class="icon-circle"> <span>Los Angeles</span>
            </div>
            <div class="region-stats" id="stats-LA"></div>
        </div>
        
        <div class="custom-option" data-value="singapore">
            <div class="region-label-group">
                <img src="/navi.io/flags/sgp.png" class="icon-circle"> <span>Singapore</span>
            </div>
            <div class="region-stats" id="stats-singapore"></div>
        </div>
        
        <div class="custom-option" data-value="tokyo">
            <div class="region-label-group">
                <img src="/navi.io/flags/tokyo.png" class="icon-circle"> <span>Tokyo</span>
            </div>
            <div class="region-stats" id="stats-tokyo"></div>
        </div>
        
        <div class="custom-option" data-value="sydney">
            <div class="region-label-group">
                <img src="/navi.io/flags/sydney.png" class="icon-circle"> <span>Sydney</span>
            </div>
            <div class="region-stats" id="stats-sydney"></div>
        </div>
    </div>
    <input type="hidden" id="regionSelect" value="atlanta">
</div>

    <input type="text" id="playerName" placeholder="Enter your name" maxlength="18" class="menu-input">
    <div class="cf-turnstile" 
        data-sitekey="0x4AAAAAACL3tHxKP9xDWcuv" 
        data-callback="onTurnstileSuccess">
    </div>
<button class="spawn-btn" onclick="startGame()">Play!</button>
<button id="copyPartyBtn" class="spawn-btn show-button" style="background: #444; margin-top: 5px;" onclick="copyPartyLink()">
    Copy Lobby Link
</button>
        
        <div class="menu-footer">
            <span>WASD / Mouse</span>
            <span>E = Autofire Â· C = Autospin Â· Left Shift = Drone Repel</span>
        </div>
    </div>
</div>
</div>
     <div id="death-screen">
    <div class="death-card">
        <h1 class="death-title">You Died</h1>
        <canvas id="deathTankCanvas" width="140" height="140"></canvas>
        <div id="death-stats"></div>
        
        <div id="save-link-container">
            <div style="font-size: 12px; margin-bottom: 5px; color: #aaa;">Copy Save Link:</div>
            <input type="text" id="saveLinkInput" class="save-input" readonly onclick="this.select()">
        </div>

        <div class="death-buttons">
            <button class="death-btn primary" onclick="resetToMenu()">Return to Menu</button>
        </div>
    </div>
</div>
<button onclick="resetToMenu()" style="padding:12px 40px; cursor:pointer; background:#555; color:white; border-radius:4px;">Continue</button>
        <div id="evolution-menu"></div>
        <div id="upgrades" class="hidden"><div style="color: #ffeb3b; font-size: 14px; font-weight:bold;">Points: <span id="pt-count">0</span></div><div id="stat-list"></div></div>
        <div id="leaderboard" class="hidden"></div>
        <div id="hud-bottom" class="hidden"><div id="tank-name-display" style="color:white; font-weight:bold;"></div><div class="progress-container"><div id="xp-bar"></div></div><div id="lvl-txt" style="color:white; font-size:12px;">Level 1</div></div>
       <div id="minimap-header" class="hidden">
    <div class="brand">navi.io</div>
    <div class="count"><span id="total-player-count">0</span> players</div>
    <div id="ping-display" class="count">0.0 ms fra</div>
</div>
        
        <div id="minimap" class="hidden"><canvas id="minimapCanvas" width="150" height="150"></canvas></div>
<script>// 1. Configuration Mapping for URL parsing
const urlRegionMap = {
    'fra': 'frankfurt',
    'atl': 'atlanta',
    'lax': 'LA',
    'hkg': 'hongkong',
    'sgp': 'singapore'
    'tok': 'tokyo',
    'syd': 'sydney'
};

const urlModeMap = {
    'f': 'FFA',
    '2': 'TEAMS',
    '4': '4TEAMS',
    'm': 'MAZE'
};

const teamColorMap = {
    'bl': '#00b2e1', // Blue
    're': '#f14e54', // Red
    'gr': '#73c176', // Green
    'pu': '#bf7ff5'  // Purple
};
function saveGame() {
    if (gameState !== 'PLAYING' || !player) return;

    const timeAlive = Math.floor((Date.now() - gameStartTime) / 1000);
    
    const saveData = {
        region: selectedRegion,
        mode: gameMode,
        player: {
            name: player.name,
            score: player.score,
            level: player.level,
            tank: player.type,
            team: player.team,
            stats: [...player.stats],
            timeAlive: timeAlive
        },
        bots: entities.filter(e => !e.isShape).map(b => ({
            name: b.name,
            score: b.score,
            level: b.level,
            tank: b.type,
            team: b.team,
            x: b.x,
            y: b.y,
            stats: [...b.stats]
        }))
    };

    // FIX: Encode Unicode characters safely before btoa
    const jsonString = JSON.stringify(saveData);
    const encoded = btoa(unescape(encodeURIComponent(jsonString)));
    
    const fullUrl = window.location.origin + window.location.pathname + "?save=" + encoded;

    const ds = document.getElementById('death-screen');
    const title = ds.querySelector('.death-title');
    const linkInput = document.getElementById('saveLinkInput');
    const linkContainer = document.getElementById('save-link-container');

    ds.classList.add('saved-theme');
    title.innerText = "Saved";
    linkInput.value = fullUrl;
    linkContainer.style.display = 'flex';

    endGame(); 
}
// 2. Main function to parse URL and update UI/State
function parseLobbyUrl() {
    const params = new URLSearchParams(window.location.search);
    const lobby = params.get('lobby');
    const teamParam = params.get('team');

    if (!lobby) return;

    // Example lobby: fraf-5419585530.navi.io:3000
    // Parts: [fra][f] - [id]
    const regionCode = lobby.substring(0, 3);
    const modeCode = lobby.substring(3, 4);
    
    const targetRegion = urlRegionMap[regionCode];
    const targetMode = urlModeMap[modeCode];

    if (targetRegion) {
        updateDropdownSelection('customRegionSelect', targetRegion);
    }

    if (targetMode) {
        updateDropdownSelection('modeDropdown', targetMode);
        // Set the global gameMode variable
        if (typeof gameMode !== 'undefined') gameMode = targetMode;
    }

    // Pre-assign team if specified
    if (teamParam && teamColorMap[teamParam]) {
        // We create a global variable that startGame() will check
        window.preAssignedTeam = teamColorMap[teamParam];
        console.log("Team pre-assigned:", window.preAssignedTeam);
    }
    // Update your parseLobbyUrl logic to this:
const saveParam = params.get('save');
if (saveParam) {
    try {
        // FIX: Decode Unicode characters safely after atob
        const decodedJson = decodeURIComponent(escape(atob(saveParam)));
        window.preparedSave = JSON.parse(decodedJson);
        
        console.log("Save link loaded successfully");
        updateDropdownSelection('modeDropdown', window.preparedSave.mode);
        updateDropdownSelection('customRegionSelect', window.preparedSave.region);
    } catch(e) { 
        console.error("Invalid save link or encoding error:", e); 
    }
}
}
    

// 3. Helper to update your custom dropdown UI visually
function updateDropdownSelection(containerId, value) {
    const container = document.getElementById(containerId);
    const hiddenInput = container.querySelector('input[type="hidden"]');
    const label = container.querySelector('.select-label');
    const option = container.querySelector(`.custom-option[data-value="${value}"]`);

    if (option) {
        hiddenInput.value = value;
        label.innerHTML = option.innerHTML;
        label.className = option.className.replace('custom-option', 'select-label');
    }
}
// Run on load
window.addEventListener('DOMContentLoaded', parseLobbyUrl);</script>
<script>
    function onTurnstileSuccess(token) {
    setTimeout(() => {
        const turnstileWidget = document.querySelector('.cf-turnstile');
        const spawnBtn = document.querySelector('.spawn-btn');
        if (turnstileWidget) {
            turnstileWidget.style.display = 'none';
        }
        if (spawnBtn) {
            spawnBtn.classList.add('show-button');
        }
    }, 800);
}
const regionCodes = {
    frankfurt: 'fra',
    atlanta: 'atl',
    LA: 'lax',
    singapore: 'sgp',
    tokyo: 'tok',
    sydney: 'syd'
};
function copyPartyLink() {
    const mode = document.getElementById('modeSelect').value; 
    const regionRaw = document.getElementById('regionSelect').value; 
   const rCode = regionCodes[regionRaw] || 'fra';
    const randomId = Math.floor(Math.random() * 9000000000) + 1000000000;
    const baseUrl = window.location.origin + window.location.pathname;
    
    let lobbyParam = "";
    let teamParam = "";
    if (mode === 'FFA') {
        lobbyParam = `?lobby=${rCode}f-${randomId}.navi.io:3000`;
    } else if (mode === 'TEAMS') {
        lobbyParam = `?lobby=${rCode}2-${randomId}.navi.io:3000`;
        //teamParam = "&team=bl"; // Example blue team
    } else if (mode === '4TEAMS') {
        lobbyParam = `?lobby=${rCode}4-${randomId}.navi.io:3000`;
        //teamParam = "&team=pu"; // Example purple team
    } else if (mode === 'MAZE') {
        lobbyParam = `?lobby=${rCode}m-${randomId}.navi.io:3000`;
    }

    const fullLink = baseUrl + lobbyParam + teamParam;
    navigator.clipboard.writeText(fullLink).then(() => {
        const btn = document.getElementById('copyPartyBtn');
        const originalText = btn.innerText;
        btn.innerText = "Copied!";
        btn.style.background = "#73c176";
        
        setTimeout(() => {
            btn.innerText = originalText;
            btn.style.background = "#444";
        }, 2000);
    });
}
function getDarkStroke(hex) {
    hex = hex.replace('#', '');
    let r = parseInt(hex.substring(0, 2), 16);
    let g = parseInt(hex.substring(2, 4), 16);
    let b = parseInt(hex.substring(4, 6), 16);

    r = Math.floor(r * 0.72);
    g = Math.floor(g * 0.72);
    b = Math.floor(b * 0.72);
    return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
}
function setupCustomDropdown(containerId) {
    const container = document.getElementById(containerId);
    const trigger = container.querySelector('.select-trigger');
    const options = container.querySelectorAll('.custom-option');
    const hiddenInput = container.querySelector('input[type="hidden"]');
    const label = container.querySelector('.select-label');

    // Toggle open
    trigger.addEventListener('click', (e) => {
        // Close others
        document.querySelectorAll('.custom-select').forEach(s => {
            if(s !== container) s.classList.remove('open');
        });
        container.classList.toggle('open');
        e.stopPropagation();
    });
options.forEach(opt => {
    opt.addEventListener('click', () => {
        const val = opt.dataset.value;
        const content = opt.innerHTML; 
        
        hiddenInput.value = val;
        label.innerHTML = content;
        container.classList.remove('open');
        if(containerId === 'customRegionSelect') {
            updateRegionDropdownUI();
        }
    });
});
}
setupCustomDropdown('modeDropdown');
setupCustomDropdown('customRegionSelect');
window.addEventListener('click', () => {
    document.querySelectorAll('.custom-select').forEach(s => s.classList.remove('open'));
});
window.addEventListener('click', (e) => {
    if (!customSelect.contains(e.target)) {
        customSelect.classList.remove('open');
    }
});
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const mCanvas = document.getElementById('minimapCanvas');
const mctx = mCanvas.getContext('2d');
const ARENA_SIZE = 4500;

let REGION_NAMES = {};
async function loadRegionNames() {
    try {
        const response = await fetch('/navi.io/names.json');
        
        if (!response.ok) {
            throw new Error(`http error :${response.status}`);
        }
        
        REGION_NAMES = await response.json();
    } catch (error) {
        console.error("names failed:", error);
    }
}

// Execute the function
loadRegionNames();

let kills = 0;
let gameStartTime = 0;
const TANK_TYPES = {
    basic: { barrels: [{x:0, y:-0.35, w:1.8, h:0.7, ang:0}], dmgMult: 1, baseReload: 50 },
    twin: { barrels: [{x:0, y:-0.7, w:1.8, h:0.6, ang:0}, {x:0, y:0.1, w:1.8, h:0.6, ang:0}], dmgMult: 0.6, baseReload: 25 },
   tripleShot: { 
        barrels: [
            {x:0, y:-0.3, w:1.8, h:0.6, ang:0}, 
            {x:0, y:-0.3, w:1.8, h:0.6, ang: 0.5}, 
            {x:0, y:-0.3, w:1.8, h:0.6, ang: -0.5}
        ], 
        dmgMult: 0.6, baseReload: 35 
    },
    spike: { barrels: [], isSpike: true },
    sniper: { barrels: [{x:0, y:-0.2, w:2.4, h:0.4, ang:0}], dmgMult: 1.25, baseReload: 100 },
    machine: { barrels: [{x:0, y:-0.5, w:1.7, h:1.0, ang:0}], dmgMult: 0.75, baseReload: 22, spread: 0.65 },
    flankGuard: { barrels: [{x:0, y:-0.35, w:1.8, h:0.7, ang:0}, {x:0, y:-0.35, w:1.8, h:0.7, ang: Math.PI}], dmgMult: 1, baseReload: 50 },
    triAngle: { barrels: [{x:0, y:-0.35, w:1.8, h:0.7, ang:0}, {x:0, y:-0.3, w:1.5, h:0.5, ang: 2.6}, {x:0, y:-0.3, w:1.5, h:0.5, ang: -2.6}], dmgMult: 0.8, baseReload: 25 },
    destroyer: { barrels: [{x:0, y:-0.6, w:1.8, h:1.2, ang:0}], dmgMult: 3.5, baseReload: 150, bulletSize: 2.5 },
    trapper: { barrels: [{x:0, y:-0.4, w:1.2, h:0.8, ang:0, trap:true}], dmgMult: 1.5, baseReload: 80, isTrapper: true },
    hexaTank: { 
       barrels: [
        {x: 0, y: -0.35, w: 1.7, h: 0.65, ang: 0},             
        {x: 0, y: -0.35, w: 1.7, h: 0.65, ang: Math.PI / 3},   
        {x: 0, y: -0.35, w: 1.7, h: 0.65, ang: (2 * Math.PI) / 3}, 
        {x: 0, y: -0.35, w: 1.7, h: 0.65, ang: Math.PI},         
        {x: 0, y: -0.35, w: 1.7, h: 0.65, ang: (4 * Math.PI) / 3},
        {x: 0, y: -0.35, w: 1.7, h: 0.65, ang: (5 * Math.PI) / 3} 
       ], 
    dmgMult: 0.6, 
    baseReload: 50 
    },
    streamliner: { 
    barrels: [
        {x:0, y:-0.3, w:2.2, h:0.4, ang:0},
        {x:0, y:-0.28, w:2.0, h:0.4, ang:0},
        {x:0, y:-0.26, w:1.8, h:0.4, ang:0},
        {x:0, y:-0.24, w:1.6, h:0.4, ang:0},
        {x:0, y:-0.22, w:1.4, h:0.4, ang:0}
    ], 
    dmgMult: 0.24, 
    baseReload: 50, // Extremely fast
    spread: 0.2
},
    overseer: { barrels: [{x:0, y:-0.3, w:1.35, h:0.8, ang:Math.PI/2, trap:true}, {x:0, y:-0.3, w:1.35, h:0.8, ang:-Math.PI/2, trap:true}], isDroneSpawner: true, maxDrones: 8, dmgMult: 1.8, baseReload: 65 }
};

const STATS_MAP = ["regen", "maxHp", "bodyDmg", "bulletSpd", "bulletPen", "bulletDmg", "reload", "moveSpd"];
const STATS_LABELS = ["Health Regen", "Max Health", "Body Damage", "Bullet Speed", "Bullet Pen", "Bullet Dmg", "Reload", "Move Speed"];

const SHAPES = {
    sq: { sides: 4, hp: 15, xp: 25, size: 21, color: '#ffe869' },
    tr: { sides: 3, hp: 35, xp: 75, size: 23, color: '#fc7677' },
    pt: { sides: 5, hp: 140, xp: 380, size: 32, color: '#768dfc' },
    hx: { sides: 6, hp: 700, xp: 2500, size: 48, color: '#00ffff' },
};
let selectedRegion = "atlanta";
let gameState = 'MENU', gameMode = 'FFA', player, entities = [], bullets = [], drones = [], keys = {}, mouse = {x: 0, y: 0}, camera = {x:2000, y:2000}, currentZoom = 1, autoFire = false, autoSpin = false;
const GAME_MODES = {
    FFA: 'FFA',
    TEAMS: 'TEAMS',
    TEAMS_4: '4TEAMS',
    MAZE: 'MAZE'
};
const getScoreForLevel = (lvl) => Math.floor(20 * Math.pow(lvl, 1.85));
const formatScore = (num) => Math.floor(num).toLocaleString();
let walls = [];
const TEAM_COLORS = {
    BLUE: '#00b2e1',   // Top Left
    RED: '#f14e4e',    // Bottom Right
    GREEN: '#87ff66',  // Bottom Left
    YELLOW: '#e40ee8'  // Top Right
};
function exitGame() {
        if (confirm("Are you sure you want to exit to the menu?")) {
            endGame();
            resetToMenu();
            document.getElementById('exit-btn').style.display = 'none';
        }
    }
// 1. Maze Generation Logic
function generateMaze() {
    walls = [];
    if (gameMode !== 'MAZE') return;

    const cellSize = 450;
    const wallThickness = 30;
    const gapSize = 120; // How wide the opening in the wall is
    const gapChance = 0.3; // 15% of walls will have a gap
    
    const cols = Math.floor(ARENA_SIZE / cellSize);
    const rows = Math.floor(ARENA_SIZE / cellSize);
    
    // 1. Standard Recursive Backtracker Setup
    const grid = Array(rows).fill().map(() => Array(cols).fill().map(() => ({
        visited: false,
        walls: { south: true, east: true }
    })));

    const stack = [];
    let current = { r: 0, c: 0 };
    grid[0][0].visited = true;
    let visitedCount = 1;
    const totalCells = rows * cols;

    while (visitedCount < totalCells) {
        let neighbors = [];
        let { r, c } = current;

        if (r > 0 && !grid[r - 1][c].visited) neighbors.push({ r: r - 1, c, dir: 'N' });
        if (r < rows - 1 && !grid[r + 1][c].visited) neighbors.push({ r: r + 1, c, dir: 'S' });
        if (c > 0 && !grid[r][c - 1].visited) neighbors.push({ r, c: c - 1, dir: 'W' });
        if (c < cols - 1 && !grid[r][c + 1].visited) neighbors.push({ r, c: c + 1, dir: 'E' });

        if (neighbors.length > 0) {
            let next = neighbors[Math.floor(Math.random() * neighbors.length)];
            if (next.dir === 'N') grid[next.r][next.c].walls.south = false;
            if (next.dir === 'S') grid[r][c].walls.south = false;
            if (next.dir === 'W') grid[next.r][next.c].walls.east = false;
            if (next.dir === 'E') grid[r][c].walls.east = false;

            grid[next.r][next.c].visited = true;
            visitedCount++;
            stack.push(current);
            current = { r: next.r, c: next.c };
        } else if (stack.length > 0) {
            current = stack.pop();
        } else break;
    }

    // 2. The "Opening" Logic
    const addWallWithGaps = (x, y, w, h, isHorizontal) => {
        if (Math.random() < gapChance) {
            // Split one wall into two pieces with a gap in the center
            if (isHorizontal) {
                let segmentWidth = (w - gapSize) / 2;
                walls.push({ x: x, y: y, w: segmentWidth, h: h });
                walls.push({ x: x + segmentWidth + gapSize, y: y, w: segmentWidth, h: h });
            } else {
                let segmentHeight = (h - gapSize) / 2;
                walls.push({ x: x, y: y, w: w, h: segmentHeight });
                walls.push({ x: x, y: y + segmentHeight + gapSize, w: w, h: segmentHeight });
            }
        } else {
            // Draw a standard solid wall
            walls.push({ x, y, w, h });
        }
    };

    // 3. Convert Grid to Game Objects
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            let x = c * cellSize;
            let y = r * cellSize;

            if (grid[r][c].walls.east && c < cols - 1) {
                addWallWithGaps(x + cellSize, y, wallThickness, cellSize + wallThickness, false);
            }
            if (grid[r][c].walls.south && r < rows - 1) {
                addWallWithGaps(x, y + cellSize, cellSize + wallThickness, wallThickness, true);
            }
        }
    }
}
// 2. Collision Detection for Walls
function checkWallCollision(ent) {
    const r = ent.radius || ent.size || 20;
    let hit = false;

    walls.forEach(w => {
        // Find the closest point on the wall to the entity center
        let closestX = Math.max(w.x, Math.min(ent.x, w.x + w.w));
        let closestY = Math.max(w.y, Math.min(ent.y, w.y + w.h));

        let dx = ent.x - closestX;
        let dy = ent.y - closestY;
        let distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < r) {
            hit = true;
            // Projectiles get destroyed
            if (ent.isBullet || ent.isDrone) {
                ent.hp = 0;
            } else {
                // Tanks slide against the wall
                let overlap = r - distance;
                if (distance === 0) return; // Prevent division by zero
                ent.x += (dx / distance) * overlap;
                ent.y += (dy / distance) * overlap;
            }
        }
    });
    return hit;
}
function setMode(m) { 
    gameMode = m; 
    if (m !== 'MAZE') walls = []; // Clear walls if not in Maze mode
    document.getElementById('btn-ffa').className = m === 'FFA' ? 'mode-btn active' : 'mode-btn'; 
    document.getElementById('btn-teams').className = m === 'TEAMS' ? 'mode-btn active' : 'mode-btn'; 
}

function constrain(ent) {
    const r = ent.radius || ent.size || 20;
    ent.x = Math.max(r, Math.min(ARENA_SIZE - r, ent.x));
    ent.y = Math.max(r, Math.min(ARENA_SIZE - r, ent.y));
}

function createTank(x, y, color, name, isBot = false) {
    let t = { id: Math.random(), x, y, color, name, isBot, radius: 20, level: 1, score: 0, skillPoints: 0, vx: 0, vy: 0, angle: 0, hp: 100, maxHp: 100, bodyDmg: 2, type: 'basic', reload: 0, stats: Array(8).fill(0), team: color };
    
    if(isBot) { 
        t.score = 14000 + Math.random() * 24000; 
        checkLvl(t); 
        
        const bulletStats = [3, 4, 5, 6]; 
        const otherStats = [0, 1, 2, 7]; 
        
        while(t.skillPoints > 0) {
            let randStat = (Math.random() < 0.7) ? bulletStats[Math.floor(Math.random() * bulletStats.length)] : otherStats[Math.floor(Math.random() * otherStats.length)];
            if(t.stats[randStat] < 7) { t.stats[randStat]++; t.skillPoints--; }
            else {
                let available = t.stats.map((v, i) => v < 7 ? i : -1).filter(v => v !== -1);
                if(available.length > 0) { t.stats[available[Math.floor(Math.random() * available.length)]]++; t.skillPoints--; }
                else break;
            }
        }
        const evos = ['twin', 'machine', 'sniper', 'overseer'];
        t.type = evos[Math.floor(Math.random() * evos.length)];
    }
    return t;
}

function startGame() {
    // 1. Get Selections from UI
    gameMode = document.getElementById("modeSelect").value;
    selectedRegion = document.getElementById("regionSelect").value;
    const nameInput = document.getElementById('playerName').value.trim() || "Unnamed";
    
    // Save the name to local storage immediately
    localStorage.setItem('savedPlayerName', nameInput);

    // 2. Setup Player Positioning and Color
    let startX, startY, pColor;
    const margin = 300;

    // Reset Game World Arrays early to prevent count errors during team balancing
    entities = []; 
    bullets = []; 
    drones = []; 
    // CHECK FOR SAVED DATA
    if (window.preparedSave) {
        const s = window.preparedSave;
        
        // 1. Restore the Player
        player = createTank(0, 0, s.player.team, s.player.name);
        player.score = s.player.score;
        player.level = s.player.level;
        player.type = s.player.tank;
        player.stats = [...s.player.stats];
        
        // 2. Restore Time Alive
        gameStartTime = Date.now() - (s.player.timeAlive * 1000);

        // 3. Restore the Saved Bots
        s.bots.forEach(bData => {
            const b = createTank(bData.x, bData.y, bData.team, bData.name, true);
            b.score = bData.score;
            b.level = bData.level;
            b.type = bData.tank;
            b.stats = [...bData.stats];
            entities.push(b);
        });

        // 4. Clear the save so it doesn't loop
        window.preparedSave = null;
        
        // Standard game start setup
        gameState = 'PLAYING';
        document.getElementById('menu-screen').style.display = 'none';
        document.getElementById('death-screen').style.display = 'none';
        updateUI();
        return; 
    }
    if (gameMode === 'TEAMS' || gameMode === '4TEAMS') {
        if (window.preAssignedTeam) {
            pColor = window.preAssignedTeam;
        } else {
            const teams = [TEAM_COLORS.BLUE, TEAM_COLORS.RED];
            if (gameMode === '4TEAMS') teams.push(TEAM_COLORS.GREEN, TEAM_COLORS.YELLOW);
            
            // Auto-balance: join the team with the fewest players
            const counts = teams.map(c => ({
                color: c, 
                count: entities.filter(e => !e.isShape && e.team === c).length
            }));
            pColor = counts.sort((a, b) => a.count - b.count)[0].color;
        }

        // Positioning Logic
        if (gameMode === 'TEAMS') {
            startY = Math.random() * ARENA_SIZE;
            startX = (pColor === TEAM_COLORS.BLUE) ? margin : ARENA_SIZE - margin;
        } else {
            // 4TEAMS Corner Logic
            if (pColor === TEAM_COLORS.BLUE) { startX = margin; startY = margin; }
            else if (pColor === TEAM_COLORS.RED) { startX = ARENA_SIZE - margin; startY = ARENA_SIZE - margin; }
            else if (pColor === TEAM_COLORS.GREEN) { startX = margin; startY = ARENA_SIZE - margin; }
            else if (pColor === TEAM_COLORS.YELLOW) { startX = ARENA_SIZE - margin; startY = margin; }
        }
    } else if (gameMode === 'MAZE') {
        pColor = TEAM_COLORS.BLUE;
        startX = 300; 
        startY = 300;
        generateMaze();
    } else {
        // FFA Logic
        pColor = '#00b2e1';
        startX = Math.random() * ARENA_SIZE; 
        startY = Math.random() * ARENA_SIZE;
    }

    // 3. Initialize Player Object
    player = createTank(startX, startY, pColor, nameInput);
    
    // Immediate collision check (especially important for MAZE mode)
    if (gameMode === 'MAZE') {
        for(let i = 0; i < 10; i++) {
            checkWallCollision(player);
        }
    }
    
    // Progression Setup
    player.score = 24260;
    player.level = 45;
    player.skillPoints = 44;

    // 4. Reset Game State
    kills = 0;
    gameState = 'PLAYING';
    gameStartTime = Date.now();
    lastTime = performance.now(); 

    // 5. Update UI Visibility
    document.getElementById('menu-screen').style.display = 'none';
    document.getElementById('death-screen').style.display = 'none';
    document.getElementById('minimap').classList.remove('hidden');
    document.getElementById('hud-bottom').classList.remove('hidden');
    document.getElementById('leaderboard').classList.remove('hidden');
    
    initStatsUI();
    updateUI();

    // 6. Spawn World Objects
    for(let i = 0; i < 450; i++) spawnShape();
    
    // 7. Regional Bot Balancing
    let baseBotCount = 24;
    const regionModifiers = { 'tokyo': 0.8, 'sydney': 0.3, 'atlanta': 1.5 };
    if (regionModifiers[selectedRegion]) {
        baseBotCount = Math.floor(baseBotCount * regionModifiers[selectedRegion]);
    }
    
    for(let i = 0; i < baseBotCount; i++) {
        spawnBot();
    }
    if (window.preparedSave) {
        const s = window.preparedSave;
        
        // 1. Restore Player
        player.name = s.player.name;
        player.score = s.player.score;
        player.level = s.player.level;
        player.type = s.player.tank;
        player.team = s.player.team;
        player.stats = [...s.player.stats];
        
        // 2. Restore Time Alive
        gameStartTime = Date.now() - (s.player.timeAlive * 1000);

        // 3. Replace default bots with saved bots
        entities = entities.filter(e => e.isShape); // Keep shapes, remove default bots
        s.bots.forEach(bData => {
            const b = createTank(bData.x, bData.y, bData.team, bData.name, true);
            b.score = bData.score;
            b.level = bData.level;
            b.type = bData.tank;
            b.stats = [...bData.stats];
            entities.push(b);
        });

        updateUI();
        window.preparedSave = null; // Consume the save
    }
    
    // Reset theme in case we previously "Saved"
    document.getElementById('death-screen').classList.remove('saved-theme');
    document.getElementById('death-screen').querySelector('.death-title').innerText = "Destroyed";
    document.getElementById('save-link-container').style.display = 'none';
}
// Global to hold prepared save
window.preparedSave = null;
// Clear save if mode/region changes manually
document.querySelectorAll('.custom-option').forEach(opt => {
    opt.addEventListener('click', () => {
        window.preparedSave = null; // Clear preparation on manual change
    });
    document.getElementById('exit-btn').display = 'block';
});
function spawnShape() {
    const r = Math.random(); 
    let baseType = r < 0.05 ? SHAPES.hx : (r < 0.2 ? SHAPES.pt : (r < 0.35 ? SHAPES.tr : SHAPES.sq));
    
    // 5% Chance to be a Sentry
    const isSentry = Math.random() < 0.002;

    let ent = { 
        ...baseType, 
        x: Math.random() * ARENA_SIZE, 
        y: Math.random() * ARENA_SIZE, 
        vx: 0, 
        vy: 0, 
        rot: Math.random() * 6, 
        rotSpd: (Math.random() - 0.5) * 0.05, 
        id: Math.random(),
        isShape: true 
    };

    if (isSentry) {
        ent.isSentry = true;
        ent.size *= 1.2; 
        ent.maxHp = baseType.hp * 2; 
        ent.currHp = ent.maxHp;
        ent.xp = baseType.xp * 50;
        ent.bodyDmg = ent.size / 2; 
        ent.team = 'NEUTRAL_SENTRY';
        ent.reload = 0;
        ent.turretAngle = 0;
        ent.stats = [0, 0, 0, 6, 5, 5, 6, 0]; 
        
        // Hexagons get Twin, others get Basic
        ent.turretType = (baseType === SHAPES.hx) ? 'twin' : 'basic';
    } else {
        ent.currHp = baseType.hp;
        ent.maxHp = baseType.hp;
        ent.bodyDmg = baseType.size / 3;
    }

    entities.push(ent);
}
function updateSentryAI(s) {
    if (!s.isSentry) return;

    let target = null;
    let minDist = 700; // Attack range

    // Helper to check if a target is in a safe base zone
    const isInBase = (t) => {
        const margin = 350; // Safe zone size
        if (gameMode === 'FFA' || gameMode === 'MAZE') return false; // No bases in FFA/Maze
        if (gameMode === 'TEAMS') {
            // Blue (Left), Red (Right)
            return (t.x < margin && t.team === TEAM_COLORS.BLUE) || 
                   (t.x > ARENA_SIZE - margin && t.team === TEAM_COLORS.RED);
        }
        if (gameMode === '4TEAMS') {
            // Check 4 corners
            if (t.x < margin && t.y < margin && t.team === TEAM_COLORS.BLUE) return true;
            if (t.x > ARENA_SIZE - margin && t.y > ARENA_SIZE - margin && t.team === TEAM_COLORS.RED) return true;
            if (t.x < margin && t.y > ARENA_SIZE - margin && t.team === TEAM_COLORS.GREEN) return true;
            if (t.x > ARENA_SIZE - margin && t.y < margin && t.team === TEAM_COLORS.YELLOW) return true;
        }
        return false;
    };

    // Find nearest player or bot (exclude shapes and other sentries)
    let potentialTargets = [player, ...entities].filter(e => 
        e && !e.isShape && !e.isSentry && e.hp > 0
    );

    potentialTargets.forEach(t => {
        let d = Math.hypot(t.x - s.x, t.y - s.y);
        // Target if close enough AND not sitting in their spawn base
        if (d < minDist && !isInBase(t)) {
            minDist = d;
            target = t;
        }
    });

    if (target) {
        // Smoothly rotate turret towards target
        let desiredAng = Math.atan2(target.y - s.y, target.x - s.x);
        // Simple lerp for rotation
        let diff = desiredAng - s.turretAngle;
        while (diff < -Math.PI) diff += Math.PI * 2;
        while (diff > Math.PI) diff -= Math.PI * 2;
        s.turretAngle += diff * 0.1;

        // Shoot
        fire(s);
    } else {
        // Slowly spin turret if idle
        s.turretAngle += 0.02;
    }
    
    s.reload--;
}
function spawnBot() {
    let color;
    const teams = [TEAM_COLORS.BLUE, TEAM_COLORS.RED];
    if (gameMode === '4TEAMS') teams.push(TEAM_COLORS.GREEN, TEAM_COLORS.YELLOW);
    
    if (gameMode === 'TEAMS' || gameMode === '4TEAMS') {
        const counts = teams.map(c => ({
            color: c, 
            count: (player && player.team === c ? 1 : 0) + entities.filter(e => !e.isShape && e.team === c).length
        }));
        color = counts.sort((a, b) => a.count - b.count)[0].color;
    } else { 
        color = '#f14e4e'; 
    }

    let x, y;
    const margin = 300;

    if (gameMode === 'TEAMS') {
        // 2 TEAMS Logic: Restrict X to sides, but allow any Y
        y = Math.random() * ARENA_SIZE;
        if (color === TEAM_COLORS.BLUE) {
            x = margin;
        } else {
            x = ARENA_SIZE - margin;
        }
        // Small horizontal jitter so they aren't in a perfect vertical line
        x += (Math.random() - 0.5) * 100;
    } else if (gameMode === 'MAZE') {
        // Inside startGame()
    if (gameMode === 'MAZE') {
            // FIX: Give bots a random position instead of just regenerating the maze
        x = Math.random() * ARENA_SIZE;
        y = Math.random() * ARENA_SIZE;
        
        // Ensure they don't spawn inside a wall
        let attempts = 0;
        while (checkWallCollision({x, y, radius: 25}) && attempts < 10) {
            x = Math.random() * ARENA_SIZE;
            y = Math.random() * ARENA_SIZE;
            attempts++;
        }
        }
    } else if (gameMode === '4TEAMS') {
        // 4 TEAMS Logic: Keep original corner spawning
        if (color === TEAM_COLORS.BLUE) { x = margin; y = margin; }
        else if (color === TEAM_COLORS.RED) { x = ARENA_SIZE - margin; y = ARENA_SIZE - margin; }
        else if (color === TEAM_COLORS.GREEN) { x = margin; y = ARENA_SIZE - margin; }
        else if (color === TEAM_COLORS.YELLOW) { x = ARENA_SIZE - margin; y = margin; }
        
        x += (Math.random() - 0.5) * 200;
        y += (Math.random() - 0.5) * 200;

    } else {
        // FFA Logic
        x = Math.random() * ARENA_SIZE;
        y = Math.random() * ARENA_SIZE;
    }

    const regionPool = REGION_NAMES[selectedRegion] || REGION_NAMES['frankfurt'];
    const botName = regionPool[Math.floor(Math.random() * regionPool.length)];

    entities.push(createTank(x, y, color, botName, true));
    
}
function getBotTarget(b) {
    let target = null, minDist = 800, targetType = '';
    
    // Check player - Bots attack player in FFA and MAZE
    if (player && (gameMode === 'FFA' || gameMode === 'MAZE' || player.team !== b.team)) {
        let d = Math.hypot(player.x - b.x, player.y - b.y);
        if (d < minDist) {
            target = player;
            minDist = d;
            targetType = 'tank';
        }
    }

    entities.forEach(en => {
        // Bots attack everything that isn't themselves in FFA and MAZE
        if (en.id !== b.id && (en.isShape || gameMode === 'FFA' || gameMode === 'MAZE' || en.team !== b.team)) {
            let d = Math.hypot(en.x - b.x, en.y - b.y);
            if (d < minDist) {
                target = en;
                minDist = d;
                targetType = en.isShape ? 'shape' : 'tank';
            }
        }
    });

    drones.forEach(dr => {
        // Bots also target enemy drones
        if (gameMode === 'FFA' || gameMode === 'MAZE' || dr.team !== b.team) {
            let d = Math.hypot(dr.x - b.x, dr.y - b.y);
            if (d < minDist) {
                target = dr;
                minDist = d;
                targetType = 'drone';
            }
        }
    });

    return { target, targetType };
}

function updateStatLogic(t) {
    if(t.isShape) return;
    
    // Standard calculation
    let baseMaxHp = 100 + (t.stats[1] * 25);
    let baseBodyDmg = 2 + (t.stats[2] * 4);
    
    // Apply Spike Multipliers
    if (t.type === 'spike') {
        baseMaxHp *= 1.65;
        baseBodyDmg *= 1.65;
    }

    t.maxHp = baseMaxHp;
    t.bodyDmg = baseBodyDmg;
    t.radius = 20 + (t.level * 0.35);
}

function update() {
    if(gameState !== 'PLAYING') return;
    updateStatLogic(player);
    if (player.type === 'spike' && typeof player.spikeAngle === 'undefined') player.spikeAngle = 0;
    
    // Handle Spike Rotation Input
    if (player.type === 'spike') {
        const rotSpeed = 0.09; // How fast spikes spin
        if (keys['ShiftLeft']) {
            player.spikeAngle -= rotSpeed; // Anti-Clockwise
        } else {
            player.spikeAngle += rotSpeed; // Clockwise (Default)
        }
    }
    if(autoSpin) player.angle += 0.05; if(autoFire) fire(player);
    const spd = 0.22 + player.stats[7] * 0.03;
    if(keys['KeyW']) player.vy -= spd; if(keys['KeyS']) player.vy += spd;
    if(keys['KeyA']) player.vx -= spd; if(keys['KeyD']) player.vx += spd;
    // ADD THIS: Mobile Joystick Input
    if (mobileUIEnabled && moveJoyData.active) {
        player.vx += moveJoyData.x * spd;
        player.vy += moveJoyData.y * spd;
    }
    if (mobileUIEnabled && fireJoyData.active) {
        fire(player);
    }
    player.vx *= 0.9; player.vy *= 0.9; player.x += player.vx; player.y += player.vy;
    checkWallCollision(player); // Add this line
    constrain(player);
    if(player.hp < player.maxHp) player.hp += 0.025 + player.stats[0]*0.07;
    player.reload--;

    [player, ...entities].forEach(owner => {
        if (!owner.isShape && TANK_TYPES[owner.type].isDroneSpawner) {
            let curDrones = drones.filter(d => d.ownerId === owner.id);
            if (curDrones.length < 8 && owner.reload <= 0) {
                drones.push({ id: Math.random(), ownerId: owner.id, team: owner.team, x: owner.x, y: owner.y, vx: 0, vy: 0, radius: 18, hp: 30 + owner.stats[4]*18, damage: 6 + owner.stats[5]*5, bodyDmg: 5 + owner.stats[2]*2, speed: 1.75 + owner.stats[3]*0.45 });
                owner.reload = TANK_TYPES[owner.type].baseReload * Math.pow(0.85, owner.stats[6]);
            }
        }
    });

    drones.forEach((d, idx) => {
        // Check if owner is player or still exists in entities
    let owner = (player && d.ownerId === player.id) ? player : entities.find(e => e.id === d.ownerId);
    checkWallCollision(d)
    // FIX: If owner is gone, destroy the drone
    if(!owner) { 
        drones.splice(idx, 1); 
        return; 
    }
        if(!owner) { drones.splice(idx,1); return; }
        drones.forEach(d2 => {
            if(d === d2) return;
            let dist = Math.hypot(d.x-d2.x, d.y-d2.y);
            if(dist < d.radius*2.2) { let ang = Math.atan2(d.y-d2.y, d.x-d2.x); d.vx += Math.cos(ang)*0.4; d.vy += Math.sin(ang)*0.4; }
        });
        let tx, ty;
        if(owner === player) { tx = (mouse.x - canvas.width/2)/currentZoom + player.x; ty = (mouse.y - canvas.height/2)/currentZoom + player.y; }
        else { let res = getBotTarget(owner); if(res.target) { tx = res.target.x; ty = res.target.y; } else { tx = owner.x + Math.cos(Date.now()/500+d.id)*80; ty = owner.y + Math.sin(Date.now()/500+d.id)*80; } }
        let ang = Math.atan2(ty - d.y, tx - d.x);
        let f = (owner === player && (keys['ShiftLeft'] || keys['ShiftRight'])) ? -1 : 1; 
        d.vx += Math.cos(ang) * (d.speed * 0.1) * f; d.vy += Math.sin(ang) * (d.speed * 0.1) * f;
        d.vx *= 0.95; d.vy *= 0.95; d.x += d.vx; d.y += d.vy;
        constrain(d);
        entities.forEach(en => {
            if(d.ownerId !== en.id && (en.isShape || gameMode === 'FFA' || d.team !== en.team)) {
                if(Math.hypot(d.x-en.x, d.y-en.y) < (en.radius||en.size)+d.radius) { handleDamage(en, d.damage/10, d.ownerId); d.hp -= (en.bodyDmg || 2); if(d.hp <= 0) drones.splice(idx,1); }
            }
        });
        if(player && owner.id !== player.id && (gameMode === 'FFA' || d.team !== player.team)) {
            if(Math.hypot(d.x-player.x, d.y-player.y) < player.radius + d.radius) { handleDamage(player, d.damage/10, d.ownerId); d.hp -= player.bodyDmg; if(d.hp <= 0) drones.splice(idx,1); }
        }
    });

    entities.forEach(en => { 
        if(!en.isShape) { 
            updateStatLogic(en); 
            botAI(en); 
            en.reload--; 
            en.x += en.vx; en.y += en.vy; 
            en.vx *= 0.9; en.vy *= 0.9; 
            checkWallCollision(en); 
            constrain(en); 
        } else {
            // Add this for Sentries
            if(en.isSentry) updateSentryAI(en); 
        }
        
        if(player) resolveCollision(player, en);
        entities.forEach(en2 => { if(en !== en2) resolveCollision(en, en2); });
    });

    bullets.forEach((b, i) => {
if (b.isTrap) {
        b.vx *= 0.92; // Rapidly slow down
        b.vy *= 0.92;
    }
        b.x += b.vx; b.y += b.vy; b.life--;
        if(player && b.ownerId !== player.id && (gameMode === 'FFA' || b.team !== player.team)) { 
            if(Math.hypot(b.x-player.x, b.y-player.y) < player.radius) { handleDamage(player, b.damage / 8, b.ownerId); b.hp -= player.bodyDmg; } 
        }
        drones.forEach((dr, dIdx) => {
            if (b.team !== dr.team) { if (Math.hypot(b.x - dr.x, b.y - dr.y) < dr.radius + 8) { dr.hp -= b.damage / 6; b.hp -= dr.bodyDmg; if (dr.hp <= 0) drones.splice(dIdx, 1); } }
        });
        entities.forEach(en => { 
            if(b.ownerId !== en.id && (en.isShape || gameMode === 'FFA' || b.team !== en.team)) { if(Math.hypot(b.x-en.x, b.y-en.y) < (en.radius||en.size)) { handleDamage(en, b.damage / 8, b.ownerId); b.hp -= (en.bodyDmg || 2); } } 
        });
        if(b.life<=0 || b.hp <= 0) bullets.splice(i,1);
    });
    if(player) { camera.x = player.x; camera.y = player.y; }
    updateLeaderboard();
}

function resolveCollision(a, b) {
    // If either entity is a shape, or it's FFA, or they are on different teams, they should take damage
    const isTeammate = !a.isShape && !b.isShape && (gameMode === 'TEAMS' || gameMode === '4TEAMS') && a.team === b.team;

    let rA = a.radius || a.size, rB = b.radius || b.size;
    let dx = b.x - a.x, dy = b.y - a.y, dist = Math.hypot(dx, dy), min = rA + rB;

    if (dist < min) {
        let ang = Math.atan2(dy, dx);
        let over = min - dist;

        if (isTeammate && gameMode !== 'MAZE' && gameMode !== 'FFA') {
            // Teammates: Only apply a gentle push to separate them, no damage
            let push = over * 0.5;
            a.x -= Math.cos(ang) * push;
            a.y -= Math.sin(ang) * push;
            b.x += Math.cos(ang) * push;
            b.y += Math.sin(ang) * push;
            
            // Apply a small velocity change so they don't feel "stuck"
            a.vx -= Math.cos(ang) * 0.1;
            a.vy -= Math.sin(ang) * 0.1;
            b.vx += Math.cos(ang) * 0.1;
            b.vy += Math.sin(ang) * 0.1;
        } else {
            // Enemies or Shapes: Hard collision and apply body damage
            a.x -= Math.cos(ang) * over * 0.5;
            a.y -= Math.sin(ang) * over * 0.5;
            b.x += Math.cos(ang) * over * 0.5;
            b.y += Math.sin(ang) * over * 0.5;

            handleDamage(a, (b.bodyDmg || 2) / 10, b.id);
            handleDamage(b, (a.bodyDmg || 2) / 10, a.id);
        }
    }
}

function botAI(b) {
    while(b.score >= getScoreForLevel(b.level+1) && b.level < 45) { b.level++; b.skillPoints++; }
    let res = getBotTarget(b);
    if(res.target) {
        let ang = Math.atan2(res.target.y - b.y, res.target.x - b.x); b.angle = ang; 
        if(Math.hypot(res.target.x-b.x, res.target.y-b.y) < 1000) fire(b);
        const s = 0.22 + b.stats[7]*0.03;
        if (res.targetType === 'drone') {
            let owner = (player && player.id === res.target.ownerId) ? player : entities.find(e => e.id === res.target.ownerId);
            if (owner) { let fleeAng = Math.atan2(owner.y - b.y, owner.x - b.x); b.vx -= Math.cos(fleeAng) * s; b.vy -= Math.sin(fleeAng) * s; }
        } else {
            const ideal = 140, dist = Math.hypot(res.target.x-b.x, res.target.y-b.y);
            let move = dist > ideal + 40 ? 1 : (dist < ideal - 40 ? -1 : 0);
            b.vx += Math.cos(ang)*s*move; b.vy += Math.sin(ang)*s*move;
        }
    }
}

function fire(t) {
    // Sentry Check: Use turretType if it's a sentry, otherwise use standard type
    const typeKey = t.isSentry ? t.turretType : t.type;
    
    // Safety check in case type doesn't exist
    if (!TANK_TYPES[typeKey]) return; 
    
    if (t.reload > 0 || TANK_TYPES[typeKey].isDroneSpawner) return;
    
    const cfg = TANK_TYPES[typeKey];

    cfg.barrels.forEach(b => {
        // Use turretAngle for sentries, body angle for tanks
        const baseAngle = t.isSentry ? t.turretAngle : t.angle;
        
        let finalAng = baseAngle + b.ang + (cfg.spread ? (Math.random() - 0.5) * cfg.spread : 0);
        
        // Recoil (Only affects tanks, not sentries to keep them stable)
        if (!t.isSentry) {
            let recoil = (cfg.bulletSize || 1) * 0.5;
            t.vx -= Math.cos(finalAng) * recoil;
            t.vy -= Math.sin(finalAng) * recoil;
        }

        let bulletRadius = 8 * (cfg.bulletSize || 1);
        if (t.isSentry) {
            bulletRadius = t.size * 0.25; 
        }

        bullets.push({
            ownerId: t.id,
            x: t.x + Math.cos(finalAng) * (t.isSentry ? t.size : t.radius) * 1.5,
            y: t.y + Math.sin(finalAng) * (t.isSentry ? t.size : t.radius) * 1.5,
            vx: Math.cos(finalAng) * (3.5 + t.stats[3] * 0.6),
            vy: Math.sin(finalAng) * (3.5 + t.stats[3] * 0.6),
            team: t.team, // 'NEUTRAL_SENTRY' for sentries
            // Use shape color for sentry bullets
            color: t.isSentry ? t.color : null, 
            damage: ((15 + t.stats[5] * 8) * cfg.dmgMult) * (t.isSentry ? 1.5 : 2), 
            hp: (20 + (t.stats[4] * 18)) / 2,
            life: cfg.isTrapper ? 600 : 90 + t.stats[4] * 18,
            radius: bulletRadius,
            isTrap: cfg.isTrapper
        });
    });
    t.reload = cfg.baseReload * Math.pow(0.88, t.stats[6]);
}
function handleDamage(t, a, kId) { 
    if(t.isShape) { t.currHp -= a; if(t.currHp <= 0) finalizeKill(t, kId); } 
    else { t.hp -= a; if(t.hp <= 0) { if(player && t === player) endGame(); else finalizeKill(t, kId); } } 
}

function finalizeKill(t, kId) {
    let xp = t.isShape ? t.xp : (22000 + Math.random() * 2000);
    if(player && kId === player.id) { player.score += xp; checkLvl(player); }
    else { let kb = entities.find(e => e.id === kId); if(kb) { kb.score += xp; } }
    let idx = entities.indexOf(t); if(idx > -1) { entities.splice(idx,1); if(t.isShape) spawnShape(); else setTimeout(() => spawnBot(), 3000); }
if (player && kId === player.id && !t.isShape) {
    kills++;
}

}

function checkLvl(p) { while(p.score >= getScoreForLevel(p.level+1) && p.level < 45) { p.level++; p.skillPoints++; } if(player && p === player) updateUI(); }

function initStatsUI() {
    const list = document.getElementById('stat-list'); list.innerHTML = "";
    STATS_LABELS.forEach((s, i) => {
        const row = document.createElement('div'); row.className = 'stat-row';
        row.onclick = () => { if(player && player.skillPoints > 0 && player.stats[i] < 7) { player.stats[i]++; player.skillPoints--; updateUI(); } };
        row.innerHTML = `<div style="color:white; font-size:10px; width:85px;">${s}</div><div class="stat-bar" id="stat-${i}">${Array(7).fill('<div class="stat-seg"></div>').join('')}</div>`;
        list.appendChild(row);
    });
}
function updateUI() {
    if(!player) return;

    // Update Level and Name in the HUD
    document.getElementById('tank-name-display').innerText = player.name;
    document.getElementById('lvl-txt').innerText = `Level ${player.level} ${player.type.toUpperCase()}`;

    // XP Bar
    const curSc = getScoreForLevel(player.level);
    const nxtSc = getScoreForLevel(player.level + 1);
    const progress = ((player.score - curSc) / (nxtSc - curSc)) * 100;
    document.getElementById('xp-bar').style.width = Math.min(100, progress) + "%";

    // Stat Upgrades
    document.getElementById('pt-count').innerText = player.skillPoints;
    document.getElementById('upgrades').classList.toggle("hidden", player.skillPoints <= 0);
    
    STATS_LABELS.forEach((_, i) => { 
        const bar = document.getElementById(`stat-${i}`); 
        if(bar) { 
            const segs = bar.children; 
            for(let j=0; j<7; j++) {
                segs[j].style.background = j < player.stats[i] ? '#00b2e1' : 'rgba(255,255,255,0.2)'; 
            }
        } 
    });
    const evoMenu = document.getElementById('evolution-menu');
    evoMenu.innerHTML = '';
    let options = [];

    if(player.level >= 15 && player.type === 'basic') {
        options = ['twin', 'sniper', 'machine', 'flankGuard', 'spike'];
    } else if (player.level >= 45) {
        if(player.type === 'machine') options = ['destroyer', 'streamliner'];
        if(player.type === 'sniper') options = ['overseer', 'trapper'];
        if(player.type === 'flankGuard') options = ['triAngle','hexaTank'];
        if(player.type === 'twin') options = ['tripleShot','hexaTank'];
    }

    if(options.length > 0) {
        evoMenu.style.display = 'flex';
        options.forEach(opt => {
            const btn = document.createElement('div');
            btn.className = 'evo-btn';
            btn.innerText = opt.charAt(0).toUpperCase() + opt.slice(1);
            btn.onclick = () => { player.type = opt; updateUI(); };
            evoMenu.appendChild(btn);
        });
    } else {
        evoMenu.style.display = 'none';
    }
}
function evolve(t) { player.type = t; updateUI(); }
function updateLeaderboard() {
    const lb = document.getElementById('leaderboard');
    if (!lb) return;

    // Map internal mode IDs to display names
    const modeDisplayNames = {
        'FFA': 'FFA',
        'TEAMS': '2TDM',
        '4TEAMS': '4TDM',
        'MAZE': 'Maze'
    };

    // Capitalize region name for display
    const regionDisplay = selectedRegion.charAt(0).toUpperCase() + selectedRegion.slice(1);
    const modeDisplay = modeDisplayNames[gameMode] || gameMode;

    let all = []; 
    if(player) all.push(player);
    all = [...all, ...entities.filter(e => !e.isShape)].sort((a,b) => b.score - a.score);

    // Dynamic Header: e.g., "Frankfurt 2TDM"
    lb.innerHTML = `<b>${regionDisplay} ${modeDisplay}</b><br>`; 
    
    all.slice(0, 8).forEach(t => {
        lb.innerHTML += `<div style="color:${t.team}">${t.name}: ${formatScore(t.score)}</div>`;
    });
}

function drawTank(t) {
    // Label Settings
    ctx.textAlign = "center";
    
    // Draw Name
    ctx.fillStyle = "white";
    ctx.font = "bold 14px Ubuntu";
    ctx.fillText(t.name, t.x, t.y - t.radius - 35); 

    // Draw Score
    ctx.font = "bold 11px Ubuntu";
    ctx.fillStyle = "#eeeeee"; 
    ctx.fillText(formatScore(t.score), t.x, t.y - t.radius - 22);

    // Tank Body Drawing
    ctx.save(); 
    ctx.translate(t.x, t.y); 
    
    // SPIKE RENDERING
    if (TANK_TYPES[t.type].isSpike) {
        // Use the spikeAngle we calculated in update(), default to 0 if bot/undefined
        const rot = t.spikeAngle || (Date.now() / 100); 
        ctx.rotate(rot); 
        
        const numSpikes = 16;
        ctx.fillStyle = '#555555'; // Dark grey spikes
        ctx.strokeStyle = '#333333'; // Even darker grey stroke
        ctx.lineWidth = 4; // Thicker line for spikes
        ctx.lineJoin = "round";

        ctx.beginPath();
        for (let i = 0; i < numSpikes; i++) {
            const angle = (Math.PI * 2 / numSpikes) * i;
            const outerR = t.radius * 1.6; // Spikes stick out far
            const innerR = t.radius * 0.9; // Base is slightly inside body

            // Triangle point calculation
            const ax = Math.cos(angle) * outerR;
            const ay = Math.sin(angle) * outerR;
            const bx = Math.cos(angle + 0.2) * innerR;
            const by = Math.sin(angle + 0.2) * innerR;
            const cx = Math.cos(angle - 0.2) * innerR;
            const cy = Math.sin(angle - 0.2) * innerR;

            ctx.lineTo(cx, cy);
            ctx.lineTo(ax, ay);
            ctx.lineTo(bx, by);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // Rotate back so the main body color circle isn't spinning
        ctx.rotate(-rot); 
    } else {
        // Standard Tank Rotation for non-spikes
        ctx.rotate(t.angle); 
    }

    // Standard Barrels (Only draw if NOT a spike)
    if (!TANK_TYPES[t.type].isSpike) {
        ctx.fillStyle = '#999'; 
        ctx.strokeStyle = '#555'; // Barrels keep standard metallic look
        ctx.lineWidth = 3;
        TANK_TYPES[t.type].barrels.forEach(b => {
            ctx.save(); 
            ctx.rotate(b.ang);
            if(b.trap) { 
                ctx.beginPath(); 
                ctx.moveTo(0, -t.radius * 0.4); 
                ctx.lineTo(t.radius * b.w, -t.radius * b.h); 
                ctx.lineTo(t.radius * b.w, t.radius * b.h); 
                ctx.lineTo(0, t.radius * 0.4); 
                ctx.fill(); ctx.stroke(); 
            } else { 
                ctx.fillRect(0, b.y * t.radius, b.w * t.radius, b.h * t.radius); 
                ctx.strokeRect(0, b.y * t.radius, b.w * t.radius, b.h * t.radius); 
            }
            ctx.restore();
        });
    }

    // Main Body Circle
    ctx.beginPath(); 
    ctx.arc(0, 0, t.radius, 0, Math.PI * 2); 
    ctx.fillStyle = t.team; 
    
    // --- UPDATED STROKE LOGIC ---
    // Use the darkened version of the team color
    ctx.strokeStyle = getDarkStroke(t.team);
    ctx.lineWidth = 3; 
    // -----------------------------
    
    ctx.fill(); 
    ctx.stroke(); 
    ctx.restore();

    // Health Bar
    if(t.hp < t.maxHp) { 
        ctx.fillStyle = '#555'; 
        ctx.fillRect(t.x - 20, t.y + t.radius + 10, 40, 5); 
        ctx.fillStyle = '#85e37d'; 
        ctx.fillRect(t.x - 20, t.y + t.radius + 10, 40 * (t.hp / t.maxHp), 5); 
    }
}
function render() {
    update(); ctx.clearRect(0,0,canvas.width,canvas.height); ctx.save();
    ctx.translate(canvas.width/2, canvas.height/2); ctx.scale(currentZoom, currentZoom); ctx.translate(-camera.x, -camera.y);
    ctx.fillStyle = '#cdcdcd'; ctx.fillRect(0,0,ARENA_SIZE,ARENA_SIZE);
    
    // Draw Teams Background
    if(gameMode === 'TEAMS' || gameMode === '4TEAMS') {
        const bSize = 700;
        ctx.globalAlpha = 0.15;
        if (gameMode === 'TEAMS') {
            const baseWidth = ARENA_SIZE * 0.15; 
            ctx.fillStyle = TEAM_COLORS.BLUE;
            ctx.globalAlpha = 0.1;
            ctx.fillRect(0, 0, baseWidth, ARENA_SIZE);
            ctx.fillStyle = TEAM_COLORS.RED;
            ctx.fillRect(ARENA_SIZE - baseWidth, 0, baseWidth, ARENA_SIZE);
            ctx.globalAlpha = 1.0;
        }
        if (gameMode === '4TEAMS') {
            ctx.fillStyle = TEAM_COLORS.BLUE; ctx.fillRect(0, 0, bSize, bSize);
            ctx.fillStyle = TEAM_COLORS.RED; ctx.fillRect(ARENA_SIZE - bSize, ARENA_SIZE - bSize, bSize, bSize);
            ctx.fillStyle = TEAM_COLORS.GREEN; ctx.fillRect(0, ARENA_SIZE - bSize, bSize, bSize);
            ctx.fillStyle = TEAM_COLORS.YELLOW; ctx.fillRect(ARENA_SIZE - bSize, 0, bSize, bSize);
        }
        ctx.globalAlpha = 1.0;
    }
    
    // Draw Grid
    ctx.strokeStyle = '#bbb'; for(let i=0; i<=ARENA_SIZE; i+=50) { ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,ARENA_SIZE); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0,i); ctx.lineTo(ARENA_SIZE,i); ctx.stroke(); }
    
    // Draw Walls
    if (walls.length > 0) {
        ctx.fillStyle = '#999';
        ctx.strokeStyle = '#555';
        ctx.lineWidth = 4;
        walls.forEach(w => {
            ctx.fillRect(w.x, w.y, w.w, w.h);
            ctx.strokeRect(w.x, w.y, w.w, w.h);
        });
    }
    entities.forEach(en => {
        if(en.isShape) { 
            ctx.save(); 
            ctx.translate(en.x, en.y); 
            ctx.save();
            ctx.rotate(en.rot); 
            ctx.beginPath(); 
            for(let i=0; i<en.sides; i++) ctx.lineTo(en.size*Math.cos(i*2*Math.PI/en.sides), en.size*Math.sin(i*2*Math.PI/en.sides)); 
            ctx.closePath(); 
            ctx.fillStyle = en.color; 
            ctx.fill(); 
            ctx.strokeStyle = getDarkStroke(en.color);
            ctx.lineWidth = 3; 
            ctx.stroke(); 
            ctx.restore(); // Restore from shape rotation

            // 2. Draw Sentry Turret (If applicable)
            if(en.isSentry) {
                ctx.rotate(en.turretAngle); // Rotate turret independently
                ctx.fillStyle = '#999'; 
                ctx.strokeStyle = '#555';
                ctx.lineWidth = 3;
                
                const turretCfg = TANK_TYPES[en.turretType];
                if(turretCfg) {
                    turretCfg.barrels.forEach(b => {
                        ctx.save();
                        ctx.rotate(b.ang);
                        // Draw barrel relative to shape size
                        ctx.fillRect(0, b.y * en.size, b.w * en.size * 0.6, b.h * en.size * 0.6);
                        ctx.strokeRect(0, b.y * en.size, b.w * en.size * 0.6, b.h * en.size * 0.6);
                        ctx.restore();
                    });
                }
                
                // Turret Cap
                ctx.beginPath();
                ctx.arc(0, 0, en.size * 0.4, 0, Math.PI*2);
                ctx.fillStyle = en.color; // Cap matches shape color
                ctx.fill();
                ctx.stroke();
            }

            ctx.restore(); 

            // Health Bar
            if(en.currHp < en.maxHp) { 
                ctx.fillStyle = '#555'; 
                ctx.fillRect(en.x-en.size, en.y+en.size+10, en.size*2, 5); 
                ctx.fillStyle = '#85e37d'; 
                ctx.fillRect(en.x-en.size, en.y+en.size+10, (en.size*2)*(en.currHp/en.maxHp), 5); 
            }
        } else drawTank(en);
    });
    bullets.forEach(b => { 
        ctx.beginPath(); 
        ctx.arc(b.x, b.y, b.radius || 8, 0, Math.PI*2); 
        ctx.fillStyle = b.color || b.team; 
        ctx.fill(); 
        
        ctx.strokeStyle = getDarkStroke(b.color || b.team);
        ctx.lineWidth = 1;
        ctx.stroke(); 
    });

    // Draw Drones
    drones.forEach(d => { 
        ctx.save(); 
        ctx.translate(d.x, d.y); 
        ctx.rotate(Math.atan2(d.vy, d.vx)); 
        ctx.beginPath(); 
        ctx.moveTo(12,0); ctx.lineTo(-8,-8); ctx.lineTo(-8,8); 
        ctx.closePath(); 
        ctx.fillStyle = d.team; 
        ctx.fill(); 
        
        // --- UPDATED DRONE STROKE ---
        ctx.strokeStyle = getDarkStroke(d.team);
        ctx.lineWidth = 1;
        // ----------------------------
        
        ctx.stroke(); 
        ctx.restore(); 
    });

    if(gameState === 'PLAYING' && player) drawTank(player);
    ctx.restore();

    // Minimap Rendering
    if (gameState === 'PLAYING' && player) {
        mctx.clearRect(0, 0, 150, 150);
        const s = 150 / ARENA_SIZE; 
        const mBaseSize = 700 * s; 

        if (gameMode === 'MAZE'){
            mctx.fillStyle = "rgba(255, 255, 255, 0.2)";
            walls.forEach(w => {
                mctx.fillRect(w.x * s, w.y * s, w.w * s, w.h * s);
            });
        }
        if (gameMode === 'TEAMS' || gameMode === '4TEAMS') {
            mctx.globalAlpha = 0.3;
            if (gameMode === 'TEAMS'){
                mctx.fillStyle = TEAM_COLORS.BLUE; mctx.fillRect(0, 0, mBaseSize, ARENA_SIZE);
                mctx.fillStyle = TEAM_COLORS.RED; mctx.fillRect(150 - mBaseSize, 0, mBaseSize, ARENA_SIZE);
            }
            if (gameMode === '4TEAMS') {
                mctx.fillStyle = TEAM_COLORS.BLUE; mctx.fillRect(0, 0, mBaseSize, mBaseSize);
                mctx.fillStyle = TEAM_COLORS.RED; mctx.fillRect(150 - mBaseSize, 150 - mBaseSize, mBaseSize, mBaseSize);
                mctx.fillStyle = TEAM_COLORS.GREEN; mctx.fillRect(0, 150 - mBaseSize, mBaseSize, mBaseSize);
                mctx.fillStyle = TEAM_COLORS.YELLOW; mctx.fillRect(150 - mBaseSize, 0, mBaseSize, mBaseSize);
            }
            mctx.globalAlpha = 1.0;
        }

        mctx.fillStyle = "white";
        mctx.fillRect(player.x * s - 2, player.y * s - 2, 4, 4);

        entities.forEach(en => {
            if (!en.isShape) {
                mctx.fillStyle = en.team;
                mctx.fillRect(en.x * s - 1.5, en.y * s - 1.5, 3, 3);
            }
        });
    }
    requestAnimationFrame(render);
}
// Mobile State
let mobileUIEnabled = false;
const moveJoyData = { active: false, x: 0, y: 0, id: -1, el: document.getElementById('joystick-move') };
const fireJoyData = { active: false, x: 0, y: 0, id: -1, el: document.getElementById('joystick-fire') };
let fireJoystickActive = false;
// Helper to update visual knob position
function updateJoystickVisuals(joyData, touchX, touchY) {
    const rect = joyData.el.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    
    // Calculate offset
    let dx = touchX - centerX;
    let dy = touchY - centerY;
    
    // Limit distance to joystick radius (approx 60px based on your CSS)
    const distance = Math.hypot(dx, dy);
    const maxDist = 40; // Limit knob movement
    
    if (distance > maxDist) {
        dx = (dx / distance) * maxDist;
        dy = (dy / distance) * maxDist;
    }

    // Move the knob (child element)
    const knob = joyData.el.querySelector('.joystick-knob');
    knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;

    // Store normalized values (-1 to 1) for game logic
    joyData.x = dx / maxDist;
    joyData.y = dy / maxDist;
}

function resetJoystick(joyData) {
    joyData.active = false;
    joyData.x = 0;
    joyData.y = 0;
    joyData.id = -1;
    const knob = joyData.el.querySelector('.joystick-knob');
    knob.style.transform = `translate(-50%, -50%)`;
}

// Touch Event Listeners
window.addEventListener('touchstart', e => {
    // Enable mobile UI on first touch
    if (!mobileUIEnabled) {
        mobileUIEnabled = true;
        document.getElementById('mobile-controls').style.display = 'block';
    }

    if (gameState !== 'PLAYING') return;

    for (let i = 0; i < e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        
        // Left side = Move
        if (t.clientX < window.innerWidth / 2) {
            if (!moveJoyData.active) {
                moveJoyData.active = true;
                moveJoyData.id = t.identifier;
                updateJoystickVisuals(moveJoyData, t.clientX, t.clientY);
            }
        } 
        else {
            if (!fireJoyData.active) {
                fireJoyData.active = true;
                fireJoyData.id = t.identifier;
                updateJoystickVisuals(fireJoyData, t.clientX, t.clientY);
                if(player) player.angle = Math.atan2(fireJoyData.y, fireJoyData.x);
            }
        }
    }
}, { passive: false });

window.addEventListener('touchmove', e => {
    if (!mobileUIEnabled || gameState !== 'PLAYING') return;
    e.preventDefault(); 

    for (let i = 0; i < e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        
        if (moveJoyData.active && t.identifier === moveJoyData.id) {
            updateJoystickVisuals(moveJoyData, t.clientX, t.clientY);
        }
        if (fireJoyData.active && t.identifier === fireJoyData.id) {
            updateJoystickVisuals(fireJoyData, t.clientX, t.clientY);
            if(player) player.angle = Math.atan2(fireJoyData.y, fireJoyData.x);
            mouse.x = (canvas.width / 2) + (dx * aimDist);
            mouse.y = (canvas.height / 2) + (dy * aimDist);
        }
    }
}, { passive: false });

window.addEventListener('touchend', e => {
    for (let i = 0; i < e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        if (moveJoyData.id === t.identifier) resetJoystick(moveJoyData);
        if (fireJoyData.id === t.identifier) resetJoystick(fireJoyData);
    }
});
const regionShortCodes = {
    frankfurt: 'fra',
    atlanta: 'atl',
    LA: 'lax',
    hongkong: 'hkg',
    singapore: 'sgp',
    tokyo: 'tok',
    sydney: 'syd',
};
function endGame() {
    gameState = 'DEAD';

    const timeAlive = Math.floor((Date.now() - gameStartTime) / 1000);

    document.getElementById('death-stats').innerHTML = `
        <b>${player.name}</b><br>
        Score: ${formatScore(player.score)}<br>
        Level: ${player.level} (${player.type.toUpperCase()})<br>
        Kills: ${kills}<br>
        Time Alive: ${timeAlive}s<br>
        Region: ${regionShortCodes[selectedRegion]}
    `;

    document.getElementById('death-screen').style.display = 'flex';
}
function resetToMenu() { 
    document.getElementById('menu-screen').style.display = 'flex';
    document.getElementById('minimap').classList.add('hidden');
    document.getElementById('hud-bottom').classList.add('hidden');
    document.getElementById('leaderboard').classList.add('hidden'); gameState = 'MENU'; player = null; document.getElementById('death-screen').style.display = 'none'; document.getElementById('menu-screen').style.display = 'flex'; document.getElementById('exit-btn').display = 'none';}

(function() {
    // Logic based on your bot population code
    const base = 24;
    const modes = 4;
    
    // Summing up all regions: 3 standard + Tokyo (0.8) + Sydney (0.3) + Atlanta (1.5)
    const frankfurt = base * modes;
    const la = base * modes;
    const hongkong = base * modes;
    const tokyo = Math.floor(base * 0.8) * modes;
    const sydney = Math.floor(base * 0.3) * modes;
    const atlanta = Math.floor(base * 1.5) * modes;
    
    const initialTotal = frankfurt + la + hongkong + tokyo + sydney + atlanta; // 536
    let currentDisplayCount = initialTotal;
    
    const countSpan = document.getElementById('total-player-count');
    const headerDiv = document.getElementById('minimap-header');

    function updateCounter() {
        // Random change 1-10
        const change = Math.floor(Math.random() * 10) + 1;
        
        // Randomly add or subtract
        if (Math.random() > 0.5) {
            currentDisplayCount += change;
        } else {
            currentDisplayCount -= change;
        }

        // Clamp: Min = initial, Max = initial + 90
        if (currentDisplayCount < initialTotal) currentDisplayCount = initialTotal;
        if (currentDisplayCount > initialTotal + 90) currentDisplayCount = initialTotal + 90;

        countSpan.innerText = currentDisplayCount.toLocaleString();

        // Random interval 8-16 seconds
        const nextInterval = Math.floor(Math.random() * (16000 - 8000 + 1)) + 8000;
        setTimeout(updateCounter, nextInterval);
    }

    // Initialize
    countSpan.innerText = initialTotal.toLocaleString();
    updateCounter();

    // Show/Hide hooks for your existing game flow
    const originalStart = window.startGame;
    window.startGame = function() {
        if (originalStart) originalStart();
        headerDiv.classList.remove('hidden');
    };

    const originalReset = window.resetToMenu;
    window.resetToMenu = function() {
        if (originalReset) originalReset();
        headerDiv.classList.add('hidden');
    };
})();
    window.networkStats = { frankfurt: 0, atlanta: 0, LA: 0, singapore: 0, tokyo: 0, sydney: 0 };
    let currentPing = 0; 
// --- Configuration ---
const basePlayerCounts = {
    'atlanta': 192,
    'frankfurt': 167,
    'LA': 139,
    'singapore': 128,
    'tokyo': 84,
    'sydney': 30
};

// Track the lowest ping seen this session
window.minPings = { 
    frankfurt: Infinity, 
    atlanta: Infinity, 
    LA: Infinity, 
    singapore: Infinity, 
    tokyo: Infinity, 
    sydney: Infinity 
};

// Track calculated player counts (static per session or slowly updating)
window.regionPlayerCounts = {};

// Initialize Player Counts once on load
function initPlayerCounts() {
    Object.keys(basePlayerCounts).forEach(region => {
        // Base + Random(0-13)
        const count = basePlayerCounts[region] + Math.floor(Math.random() * 14);
        window.regionPlayerCounts[region] = count;
    });
}
initPlayerCounts(); // Run immediately

async function updateGlobalPings() {
    // Initialize global storage if they don't exist
    window.networkStats = window.networkStats || {};
    window.minPings = window.minPings || {};

    const endpoints = {
        frankfurt: "https://dynamodb.eu-central-1.amazonaws.com",
        atlanta: "https://dynamodb.us-east-2.amazonaws.com",
        LA: "https://dynamodb.us-west-2.amazonaws.com",
        singapore: "https://dynamodb.ap-southeast-1.amazonaws.com",
        tokyo: "https://dynamodb.ap-northeast-1.amazonaws.com",
        sydney: "https://dynamodb.ap-southeast-2.amazonaws.com"
    };

    const promises = Object.entries(endpoints).map(async ([key, url]) => {
        const start = performance.now();
        try {
            // Using 'head' can be even lighter than a full GET
            await fetch(url, { mode: 'no-cors', cache: 'no-cache', method: 'HEAD' });
            const end = performance.now();
            const pingValue = parseFloat((end - start).toFixed(1));

            // Update stats
            window.networkStats[key] = pingValue;
            
            // Record the best (minimum) ping for this session
            if (!window.minPings[key] || pingValue < window.minPings[key]) {
                window.minPings[key] = pingValue;
            }

            // UI Update for the active selection
            const activeRegion = document.getElementById("regionSelect")?.value;
            if (key === activeRegion) {
                const display = document.getElementById('ping-display');
                if (display) {
                    const shortCode = (typeof regionShortCodes !== 'undefined' && regionShortCodes[key]) || key;
                    display.innerText = `${pingValue} ms ${shortCode}`;
                }
                // Update global game delay variable
                if (typeof currentPing !== 'undefined') currentPing = Math.round(pingValue);
            }

        } catch (e) {
            console.error(`Ping failed for ${key}:`, e);
            window.networkStats[key] = 999;
            if (!window.minPings[key]) window.minPings[key] = 999;
        }
    });

    await Promise.all(promises);
    
    if (typeof updateRegionDropdownUI === 'function') {
        updateRegionDropdownUI();
    }
}

function updateRegionDropdownUI() {
    const optionsContainer = document.querySelector('#customRegionSelect .custom-options');
    const options = Array.from(document.querySelectorAll('#customRegionSelect .custom-option'));

    options.forEach(opt => {
        const regionKey = opt.getAttribute('data-value');
        const statsContainer = opt.querySelector('.region-stats');
        
        // 1. Get Values
        const count = window.regionPlayerCounts[regionKey] || 0;
        const ping = window.minPings[regionKey];
        const pingDisplay = (ping === Infinity || ping === 999) ? "..." : Math.round(ping) + "ms";

        // 2. Build HTML
        statsContainer.innerHTML = `
            <span class="stat-players">
                <img src="/navi.io/Assets/player.png" class="stat-icon">
                ${count}
            </span>
            <span class="stat-ping">
                <img src="/navi.io/Assets/ping.png" class="stat-icon">
                ${pingDisplay}
            </span>
        `;
    });

    // 3. Sorting: Lowest Ping First
    options.sort((a, b) => {
        const keyA = a.getAttribute('data-value');
        const keyB = b.getAttribute('data-value');
        return window.minPings[keyA] - window.minPings[keyB];
    });

    // Re-append in new order
    options.forEach(opt => optionsContainer.appendChild(opt));

    // 4. Update the Active Trigger Visuals
    // We need to refresh the trigger because the innerHTML of the selected option changed
    const currentVal = document.getElementById('regionSelect').value;
    const currentOpt = options.find(o => o.getAttribute('data-value') === currentVal);
    
    if (currentOpt) {
        const triggerLabel = document.querySelector('#customRegionSelect .select-label');
        triggerLabel.innerHTML = currentOpt.innerHTML;
    }
}
setInterval(updateGlobalPings, 5000);
updateGlobalPings(); // Initial call
window.addEventListener('touchmove', e => {
    if(!player || gameState !== 'PLAYING') return;
    for(let i=0; i<e.touches.length; i++) {
        const t = e.touches[i];
        if(joystick.active && t.clientX < window.innerWidth / 2) {
            let dx = t.clientX - joystick.startX, dy = t.clientY - joystick.startY, dist = Math.hypot(dx, dy), max = 50;
            if(dist > max) { dx *= max/dist; dy *= max/dist; }
            joystick.x = dx; joystick.y = dy; joyStick.style.transform = `translate(${dx}px, ${dy}px)`;
        } else if(!autoSpin) player.angle = Math.atan2((t.clientY-canvas.height/2)/currentZoom, (t.clientX-canvas.width/2)/currentZoom);
    }
}, {passive: false});
window.addEventListener('keydown', e => { 
    mobileUIEnabled = false;
        setTimeout(() => {
            keys[e.code] = true; 
            if(e.code === 'KeyE') autoFire = !autoFire; 
            if(e.code === 'KeyC') autoSpin = !autoSpin;
            if(e.code === 'Semicolon') saveGame();
        }, currentPing);
    });
window.addEventListener('keyup', e => {
        setTimeout(() => {
            keys[e.code] = false;
        }, currentPing);
    });
// Mouse Aiming
    window.addEventListener('mousemove', e => { 
        currentPing = window.networkStats[document.getElementById("regionSelect").value];
        const mx = e.clientX;
        const my = e.clientY;
        
        setTimeout(() => {
            mouse.x = mx; 
            mouse.y = my; 
            if(player && !autoSpin) {
                player.angle = Math.atan2((my - canvas.height/2)/currentZoom, (mx - canvas.width/2)/currentZoom);
            }
        }, currentPing);
    });
// Firing (Click)
    window.addEventListener('mousedown', () => { 
        setTimeout(() => {
            if(gameState === 'PLAYING' && player) fire(player); 
        }, currentPing);
    });
window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; });
window.addEventListener('DOMContentLoaded', () => {
    const savedName = localStorage.getItem('savedPlayerName');
    const nameInput = document.getElementById('playerName');
    
    if (savedName && nameInput) {
        nameInput.value = savedName;
    }
});
canvas.width = window.innerWidth; canvas.height = window.innerHeight;
render();
</script>

</body></html>
